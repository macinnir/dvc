package dump

import (
	"fmt"
	"strings"
	"time"

	"github.com/macinnir/dvc/core/connectors"
	"github.com/macinnir/dvc/core/lib"
	"github.com/macinnir/dvc/core/lib/executor"
	"github.com/macinnir/dvc/core/lib/importer"
	"github.com/macinnir/dvc/core/lib/schema"
	"github.com/macinnir/dvc/core/lib/sql"
	"go.uber.org/zap"
)

const CommandName = "dump"

func dbFieldCleanString(val string) string {

	return strings.ReplaceAll(
		strings.ReplaceAll(
			strings.ReplaceAll(
				val,
				"\\", "\\\\",
			),
			"'", `''`,
		), "<nil>", "NULL")
}

// Dump produces sql insert statements for the database
func Cmd(logger *zap.Logger, config *lib.Config, args []string) error {

	var q = sql.Query{}
	var e error
	var remoteSchemas map[string]*schema.Schema
	remoteSchemas, e = importer.FetchAllSchemas(config)
	if e != nil {
		return fmt.Errorf("Error importing schemas: %w", e)
	}

	configMap := map[string]*lib.ConfigDatabase{}
	for k := range config.Databases {
		configMap[config.Databases[k].Key] = config.Databases[k]
	}

	var schemaName = ""
	var tableName = ""
	var databaseName = ""
	var dataOnly = false
	var schemaOnly = false
	// var outputPath = ""

	fmt.Println("--")
	fmt.Println("-- DVC Database Dump Utility")

	if len(args) > 1 {
		for len(args) > 0 {
			if args[0] == "-t" || args[0] == "--table" {
				tableName = args[1]
				args = args[2:]
				continue
			}

			if args[0] == "-s" || args[0] == "--schema" {
				schemaName = args[1]
				args = args[2:]
				fmt.Printf("-- Extracting for database `%s`\n", schemaName)
				continue
			}

			if args[0] == "-d" || args[0] == "--dataonly" {
				dataOnly = true
				args = args[1:]
				fmt.Printf("-- Data only mode\n")
				continue
			}

			if args[0] == "-c" || args[0] == "--schemaonly" {
				schemaOnly = true
				args = args[1:]
				fmt.Printf("-- Schema only mode\n")
				continue
			}

			// if args[0] == "-p" || args[0] == "--path" {
			// 	outputPath = args[1]
			// 	args = args[2:]
			// 	continue
			// }
		}
	}

	var schemaFound = false

	if len(tableName) > 0 || len(schemaName) > 0 {
		for _, db := range remoteSchemas {
			if len(schemaName) > 0 && db.Name == schemaName {
				schemaFound = true
				break
			}

			// fmt.Println("Database Key: ", db.Name)
			// fmt.Println("Database Name: ", db.Name)
			if db.Tables != nil {
				for _, table := range db.ToSortedTables() {
					if tableName == table.Name {
						databaseName = db.Name
						break
					}
				}
			}
		}
	}

	if len(schemaName) > 0 && !schemaFound {
		return fmt.Errorf("Schema %s not found", schemaName)
	}

	if len(tableName) > 0 && len(databaseName) == 0 {
		return fmt.Errorf("Table %s not found in any database", tableName)
	}

	fmt.Println("-- Generated by DVC - Database Version Control (https://github.com/macinnir/dvc)")
	fmt.Println("-- Dump started at ", time.Now().Format("2006-01-02 15:04:05 EST"))
	fmt.Println("--")

	for connectionKey := range remoteSchemas {

		var connector, e = connectors.DBConnectorFactory(configMap[connectionKey])
		if e != nil {
			return fmt.Errorf("Error creating connector for connection %s: %w", connectionKey, e)
		}
		var remoteSchema = remoteSchemas[connectionKey]
		if len(schemaName) > 0 && remoteSchema.Name != schemaName {
			continue
		}
		// fmt.Println("Remote Schema: ", remoteSchema.Name)
		fmt.Printf("\n\n--\n-- Database: `%s`\n-- Tables: %d\n--\n\n", remoteSchema.Name, len(remoteSchema.Tables))
		// continue
		var server = executor.NewExecutor(
			configMap[connectionKey],
			connector,
		).Connect()

		if !dataOnly {
			fmt.Printf("CREATE DATABASE IF NOT EXISTS `%s`; \nUSE `%s`;\n\n", remoteSchema.Name, remoteSchema.Name)
		}

		for _, table := range remoteSchema.ToSortedTables() {

			if len(tableName) > 0 && (databaseName != remoteSchema.Name || table.Name != tableName) {
				continue
			}

			var table = remoteSchema.Tables[table.Name]
			var values = []map[string]interface{}{}
			var valueLen = 0
			if !schemaOnly {
				// fmt.Println("-- Fetching data for table " + table.Name)
				values = connector.FetchEnum(server, table.Name)
				// fmt.Println("-- Fetched " + fmt.Sprintf("%d", len(values)) + " rows for table " + table.Name)
				valueLen = len(values)
			}

			if dataOnly && valueLen == 0 {
				continue
			}
			fmt.Printf("\n\n--\n-- Table: `%s`", table.Name)
			fmt.Printf("\n-- Database: `%s`", remoteSchema.Name)
			fmt.Printf("\n-- Columns: `%d`", len(table.Columns))
			if !schemaOnly {
				fmt.Printf("\n-- Rows: `%d`", len(values))
			}
			fmt.Print("\n--\n\n")

			cols := table.ToSortedColumns()

			colNames := []string{}
			for j := range cols {
				colNames = append(colNames, fmt.Sprintf("`%s`", cols[j].Name))
			}

			if !dataOnly {
				// Drop Table
				fmt.Printf("-- Dropping table `%s`\n", table.Name)
				fmt.Printf("DROP TABLE IF EXISTS `%s`;\n\n", table.Name)

				// Create Table
				createTableSQL, e := q.CreateTable(table)
				if e != nil {
					return fmt.Errorf("Error generating create table SQL for table %s: %w", table.Name, e)
				}
				fmt.Printf("-- Creating table `%s`\n", table.Name)
				fmt.Printf("%s\n", createTableSQL)
			}

			// Insert Data
			insertStart := fmt.Sprintf("INSERT INTO `%s` (%s) \nVALUES\n", table.Name, strings.Join(colNames, ","))

			insertBatchCounter := 0
			insertBatchMax := 100
			if valueLen > 0 {
				// if insertBatchMax < len(values) {
				// 	fmt.Printf("\n-- Inserting %d (in batches of %d) rows of data for table `%s`\n", len(values), insertBatchMax, table.Name)
				// } else {
				// 	fmt.Printf("\n-- Inserting %d rows of data for table `%s`\n", len(values), table.Name)
				// }
				fmt.Print("\n\n-- Locking tables\n")
				fmt.Printf("LOCK TABLES `%s` WRITE;\n", table.Name)
				var insertRowEnd = insertBatchMax
				if insertRowEnd > valueLen {
					insertRowEnd = valueLen
				}
				fmt.Printf("\n-- Inserting rows %d - %d of %d\n", 1, insertRowEnd, valueLen)
				fmt.Print(insertStart)
				logger.Info("Fetched " + fmt.Sprintf("%d", valueLen) + " rows for table " + table.Name)
				insertBatchCounter = 0
				for rowNum := range values {

					if insertBatchCounter > insertBatchMax {
						var insertRowEnd = rowNum + insertBatchMax
						if insertRowEnd > len(values) {
							insertRowEnd = valueLen
						}
						fmt.Printf("; \n-- Inserting rows %d - %d of %d\n%s\n", rowNum, insertRowEnd, valueLen, insertStart)
						insertBatchCounter = 0
					}

					if insertBatchCounter > 0 {
						fmt.Print(",")
					}

					insertBatchCounter++

					// fields := []string{}
					vals := []string{}
					n := 0

					for colNum := range cols {

						colName := cols[colNum].Name

						val := ""

						// fmt.Println(table.Name, ".", colName, "dataType", table.Columns[colName].DataType)

						switch strings.ToLower(table.Columns[colName].DataType) {
						case "char", "varchar", "text", "longtext", "date", "datetime", "enum":
							val = fmt.Sprintf("'%s'", dbFieldCleanString(fmt.Sprintf("%s", values[rowNum][colName])))
						default:
							if values[rowNum][colName] == nil {
								val = "NULL"
							} else {
								val = fmt.Sprintf("%v", values[rowNum][colName])
							}
						}

						vals = append(vals, val)

						n++
					}

					query := fmt.Sprintf("(%s)", strings.Join(vals, ","))

					fmt.Print(query + "\n")
				}
				fmt.Print(";\n\n-- Unlocking tables\nUNLOCK TABLES;\n\n")
			}
		}
	}

	return nil

	// reader := bufio.NewReader(os.Stdin)

	// tableName := ""

	// if len(args) > 0 {
	// 	tableName = args[0]
	// } else {
	// 	tableName = lib.ReadCliInput(reader, "Table:")
	// }

	// tables := database.ToSortedTables()
	// connector, _ := connectorFactory(c.Config.DatabaseType, c.Config)
	// server := lib.NewExecutor(c.Config, connector).Connect()

	// fmt.Println("-- DVC Table Dump")
	// fmt.Printf("-- Host: %s\t Database: %s\n", c.Config.Connection.Host, c.Config.Connection.DatabaseName)

	// insertBatchMax := 100

	// for k := range tables {

	// 	insertBatchCounter := 0
	// 	table := tables[k]

	// 	fmt.Println("")
	// 	fmt.Println("--")
	// 	fmt.Printf("-- Dumping data for table `%s`\n", table.Name)
	// 	fmt.Println("--")
	// 	fmt.Println("")

	// 	// fmt.Printf("DROP TABLE IF EXISTS `%s`;\n", table.Name)

	// 	tableData := connector.FetchEnum(server, table.Name)

	// 	cols := table.ToSortedColumns()

	// 	colNames := []string{}
	// 	for j := range cols {
	// 		colNames = append(colNames, fmt.Sprintf("`%s`", cols[j].Name))
	// 	}

	// 	insertStart := fmt.Sprintf("\nINSERT INTO `%s` (%s) VALUES ", table.Name, strings.Join(colNames, ","))

	// 	if len(tableData) > 0 {
	// 		fmt.Printf("LOCK TABLES `%s` WRITE;\n", table.Name)
	// 		fmt.Print(insertStart)
	// 		for rowNum := range tableData {

	// 			if insertBatchCounter > insertBatchMax {
	// 				fmt.Println("; \n", insertStart)
	// 				insertBatchCounter = 0
	// 			}

	// 			if insertBatchCounter > 0 {
	// 				fmt.Print(",")
	// 			}

	// 			insertBatchCounter++

	// 			// fields := []string{}
	// 			values := []string{}
	// 			n := 0

	// 			for colNum := range cols {

	// 				colName := cols[colNum].Name

	// 				// l := table.Columns[colName]
	// 				// m := tableData[rowNum][colName]

	// 				// fields = append(fields, fmt.Sprintf("`%s`", l.Name))

	// 				// fmt.Printf("Parsing value %s.%s => %s\n", table.Name, l.Name, table.Columns[colName].DataType)

	// 				// t := table.Columns[l].FmtType
	// 				val := ""

	// 				switch table.Columns[colName].DataType {
	// 				case "char", "varchar", "text", "date", "datetime", "enum":

	// 					val = fmt.Sprintf("'%s'", dbFieldCleanString(fmt.Sprintf("%s", tableData[rowNum][colName])))
	// 				default:
	// 					val = fmt.Sprintf("%v", tableData[rowNum][colName])
	// 				}
	// 				// switch table.Columns[colName].DataType {
	// 				// case "int":
	// 				// 	if table.Columns[colName].IsUnsigned {
	// 				// 		val = fmt.Sprintf("%d", int64(*(m.(*uint32))))
	// 				// 	} else {
	// 				// 		val = fmt.Sprintf("%d", int64(*(m.(*int32))))
	// 				// 	}
	// 				// case "bigint":
	// 				// 	val = fmt.Sprintf("%d", int64(*(m.(*uint64))))
	// 				// case "tinyint":
	// 				// 	if table.Columns[colName].IsUnsigned {
	// 				// 		val = fmt.Sprintf("%d", int64(*(m.(*uint8))))
	// 				// 	} else {
	// 				// 		val = fmt.Sprintf("%d", int64(*(m.(*int8))))
	// 				// 	}
	// 				// case "char", "varchar", "text":
	// 				// 	val = fmt.Sprintf("'%s'", *(m.(*string)))
	// 				// case "decimal":
	// 				// 	val = fmt.Sprintf("%f", float64(*(m.(*float64))))
	// 				// }

	// 				values = append(values, val)

	// 				n++
	// 			}

	// 			query := fmt.Sprintf("(%s)", strings.Join(values, ","))

	// 			// queries = append(queries, query)
	// 			fmt.Print(query)

	// 			// }

	// 			// sql := fmt.Sprintf("INSERT INTO `%s` (\n", table.Name)

	// 			// columnNames := []string{}
	// 			// values := []string{}

	// 			// for k := range columns {

	// 			// 	if columns[k].ColumnKey == "PRI" {
	// 			// 		continue
	// 			// 	}

	// 			// 	if columns[k].Name == "IsDeleted" {
	// 			// 		continue
	// 			// 	}

	// 			// 	columnNames = append(columnNames, fmt.Sprintf("`%s`", columns[k].Name))

	// 			// 	value := "?"
	// 			// 	if columns[k].Name == "DateCreated" {
	// 			// 		value = fmt.Sprintf("%d", time.Now().UnixNano()/1000000)
	// 			// 	} else {
	// 			// 		// value = lib.ReadCliInput(reader, columns[k].Name+" ("+columns[k].DataType+"):")
	// 			// 	}

	// 			// 	if lib.IsString(columns[k]) {
	// 			// 		value = "'" + value + "'"
	// 			// 	} else {
	// 			// 		if len(value) == 0 {
	// 			// 			value = "0"
	// 			// 		}
	// 			// 	}

	// 			// 	values = append(values, value)
	// 			// }

	// 			// sql += "\t" + strings.Join(columnNames, ",\n\t")
	// 			// sql += "\n) VALUES (\n"
	// 			// sql += "\t" + strings.Join(values, ",\n\t")
	// 			// sql += "\n)\n"
	// 			// fmt.Println(sql)
	// 		}
	// 		fmt.Print(";\nUNLOCK TABLES;\n\n")
	// 	}
	// }
	// doInsertYN := lib.ReadCliInput(reader, "Run above SQL (Y/n")

	// if doInsertYN != "Y" {
	// 	return
	// }

	// x := lib.NewExecutor(c.Config, connector)
	// x.RunSQL(sql)
}
